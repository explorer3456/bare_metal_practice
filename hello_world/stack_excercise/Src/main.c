/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>



void generate_interrupt(void)
{
       uint32_t *pSTIR = (uint32_t *)0xE000EF00;
       uint32_t *pISER0 = (uint32_t *)0xE000E100;

       // enable IRQ3
       *pISER0 |= (1<<3);

       // generate SWI
       *pSTIR = (0x3);

}

void generate_exception(void)
{
	__asm__ ("SVC 0x2");
}

void change_access_level_unpriv(void)
{
	int control_reg;

	__asm__ ("MRS %0, CONTROL":"=r"(control_reg));

	control_reg |= 0x1;

	__asm__ ("MSR CONTROL, %0"::"r"(control_reg));
}

int func_add(int a, int b, int c, int d)
{
	return a+b+c+d;
}

/*
#define SRAM_BASE	(0x20000000)
#define SRAM_SIZE	(0x20000) // 128 KB

#define MSP_SIZE	(512)
#define MSP_BASE	(SRAM_BASE + SRAM_SIZE - MSP_SIZE) // 512 Byte is size of MSP

#define PSP_SIZE	(512) // 512Byte
#define PSP_BASE	(MSP_BASE - PSP_SIZE)
*/

__attribute__((naked))void change_sp_to_psp(void)
{
	__asm__ (".equ SRAM_BASE, 0x20000000");
	__asm__ (".equ SRAM_SIZE, 0x20000");
	__asm__ (".equ MSP_SIZE, 512");
	__asm__ (".equ MSP_BASE, (SRAM_BASE + SRAM_SIZE - MSP_SIZE)");
	__asm__ (".equ PSP_SIZE, 512");
	__asm__ (".equ PSP_BASE, (MSP_BASE - PSP_SIZE)");

	__asm__ ("LDR R0, =(PSP_BASE + PSP_SIZE)"); // PSP value
	__asm__ ("MSR PSP, R0");
	__asm__ ("MRS R0, CONTROL");
	__asm__ ("ORR R0, 0X2"); // Set SPSEL to 1. PSP select.
	__asm__ ("MSR CONTROL, R0");
	__asm__ ("BX LR");
}

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	change_sp_to_psp();

	int ret;
	void (*func_ptr)(void);
    /* Loop forever */
	printf("heeee\n");

	ret = func_add(1,4,5,6);

	printf("result: %d\n", ret);

	generate_exception();
	// when you assign function pointer, compiler auto matcially assign LSB of "change_access_level_unpriv"
	// to 1. You can see that change access_level_unpriv function's address is even number such as 0x800700.
	// However, when you assign the address value of change_..x to func_ptr, the compiler put one bit to the address
	// Hence the func_ptr = 0x800701.
	// This is because Cortex M4 always run in thumb state.
	func_ptr = change_access_level_unpriv;

	//change_access_level_unpriv();
	func_ptr();

	//generate_interrupt();

	printf("hooooo\n");
	for(;;);
}

void RTC_WKUP_IRQHandler(void)
{
	printf("in handler mode\n");
}

void HardFault_Handler(void)
{
	printf("hard fault detected");
	while(1);

}
void SVC_Handler(void)
{
	printf("SVC handler");
	while(1);
}
