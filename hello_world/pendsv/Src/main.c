/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <led.h>

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);


#define TASK_STACK_SIZE	(1024U)
#define SCHED_STACK_SIZE	(1024U)

#define SRAM_BASE	(0x20000000U)
#define SRAM_SIZE	(128U * 1024U)
#define SRAM_END	(SRAM_BASE + SRAM_SIZE)

// normal memory map is defined with base and size.
// but stack memory is full descending.
// lets try with original concept, base and size.

// but look below,, it is confusing.
// #define T1_STACK_SIZE	TASK_STACK_SIZE
// #define T1_STACK_BASE	((SRAM_BASE + SRAM_SIZE) - T1_STACK_SIZE)

// below syntax looks much nicer.
#define T1_STACK_START	(SRAM_END)
#define T1_STACK_SIZE	(TASK_STACK_SIZE)
#define T1_STACK_END	(T1_STACK_START - T1_STACK_SIZE)

#define T2_STACK_START	(T1_STACK_END)
#define T2_STACK_SIZE	(TASK_STACK_SIZE)
#define T2_STACK_END	(T2_STACK_START - T2_STACK_SIZE)

#define T3_STACK_START	(T2_STACK_END)
#define T3_STACK_SIZE	(TASK_STACK_SIZE)
#define T3_STACK_END	(T3_STACK_START - T3_STACK_SIZE)

#define T4_STACK_START	(T3_STACK_END)
#define T4_STACK_SIZE	(TASK_STACK_SIZE)
#define T4_STACK_END	(T4_STACK_START - T4_STACK_SIZE)

#define T5_STACK_START	(T4_STACK_END)
#define T5_STACK_SIZE	(TASK_STACK_SIZE)
#define T5_STACK_END	(T5_STACK_START - T5_STACK_SIZE)

#define SCHED_STACK_START	(T5_STACK_END)
#define SCHED_STACK_END	(SCHED_STACK_START - SCHED_STACK_SIZE)

#define MAX_TASK	5

#define DUMMY_STACK_FRAME_SIZE	(16 * sizeof(int))

// systick timer
#define SYSTICK_HZ	(16000000)
// #define TICK_HZ	(1000U) // 1KHZ
#define TICK_HZ	(100U) // 1HZ

#define SYST_CSR_BASE	(0xE000E010)
#define SYST_RVR_BASE	(0xE000E014)


#define SCB_SHCSR_BASE	(0xE000ED24)
#define SCB_UFSR_BASE	(0xE000ED2A)
#define SCB_MMSR_BASE	(0xE000ED28)
#define SCB_MMAR_BASE	(0xE000ED34)
#define SCB_CCR_BASE	(0xE000ED14)
#define SCB_ICSR_BASE	(0xE000ED04)

// uint32_t * task_stack[MAX_TASK];

#define TASK_STATE_BLOCK	1
#define TASK_STATE_RUNNING	0

void init_systick_timer(uint32_t tick_hz);
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void idle_handler(void);

struct task_struct {
	int state;
	uint32_t * stack;
	void (*handler)(void);
	uint32_t block_count_start;
	uint32_t block_count_value;
};

int task_count = 0;
struct task_struct * current_task;
uint32_t g_counter = 0;

struct task_struct * next_task;
struct task_struct * cur_task;

struct task_struct task_info[MAX_TASK] =
{
		{
				.state = TASK_STATE_RUNNING,
				.stack = T1_STACK_START,
				.handler = task1_handler,
				.block_count_start = 0,
				.block_count_value = 0,
		},
		{
				.state = TASK_STATE_RUNNING,
				.stack = T2_STACK_START,
				.handler = task2_handler,
				.block_count_start = 0,
				.block_count_value = 0,
		},
		{
				.state = TASK_STATE_RUNNING,
				.stack = T3_STACK_START,
				.handler = task3_handler,
				.block_count_start = 0,
				.block_count_value = 0,
		},
		{
				.state = TASK_STATE_RUNNING,
				.stack = T4_STACK_START,
				.handler = task4_handler,
				.block_count_start = 0,
				.block_count_value = 0,
		},
		{
				.state = TASK_STATE_RUNNING,
				.stack = T5_STACK_START,
				.handler = idle_handler,
				.block_count_start = 0,
				.block_count_value = 0,
		}
};


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



__attribute__((naked)) void init_scheduler_stack(uint32_t stack_start)
{
	__asm__("MSR MSP, R0");
	__asm__("BX LR");
}

uint32_t * get_current_stack(void)
{
	//printf("get current stack idx: %d\n", task_count);
	// return task_stack[task_count];
	return task_info[task_count].stack;
}


void update_current_stack(uint32_t current_stack)
{
	task_info[task_count].stack = (uint32_t * )current_stack;
}

void pendsv_update_stack_pointer(uint32_t current_stack)
{
	cur_task->stack = (uint32_t * )current_stack;
}

uint32_t * pendsv_next_task_stack_pointer(void)
{
	return next_task->stack;
}

void update_task_count(void)
{
	int i;
	for (i=0; i<MAX_TASK; i++) {
		// base scheudling method is round robin. so update task counter first.
		task_count = (task_count + 1) % MAX_TASK;
		if (task_info[task_count].state == TASK_STATE_RUNNING)
			break;

	}
}

void systick_update_task_state(void)
{
	int i;

	for(i=0; i<MAX_TASK; i++) {
		if (task_info[i].state == TASK_STATE_BLOCK) {
			task_info[i].block_count_value--;
			// printf("task_info[%d].count: %d\n", i, task_info[i].block_count_value);
			if (task_info[i].block_count_value == 0) {
				task_info[i].state = TASK_STATE_RUNNING;
				// printf("task_info[%d].state is runnning\n", i);
			}
		}
	}
}

struct task_info * systick_get_next_task(void)
{
	int i;
	struct task_info * task;

	systick_update_task_state();

	for(i=0; i<MAX_TASK; i++) {

		task_count = (task_count + 1) % MAX_TASK;

		if (task_info[task_count].state == TASK_STATE_RUNNING) {
			task = &task_info[task_count];
			break;
		}
	}

	return task;
}

struct task_info * get_next_task(void)
{
	int i;
	struct task_info * task;

	for(i=0; i<MAX_TASK; i++) {

		task_count = (task_count + 1) % MAX_TASK;

		if (task_info[task_count].state == TASK_STATE_RUNNING) {
			task = &task_info[task_count];
			break;
		}
	}

	return task;
}

void schedule(void)
{
	uint32_t * pICSR = (uint32_t *)SCB_ICSR_BASE;

	cur_task = &task_info[task_count];
	next_task = get_next_task();

	if (cur_task != next_task) {
		// call enable pend SV handler.
		*pICSR |= (0x1<<28); // set pend SV exception pending.
	}
}

void task_delay(uint32_t time_ms, int task_idx)
{
	uint32_t count;

	count = ( time_ms * TICK_HZ )/1000;

	if (task_info[task_idx].state != TASK_STATE_BLOCK) {
		task_info[task_idx].block_count_value = count;
		task_info[task_idx].state = TASK_STATE_BLOCK;
	}
	schedule();
}

// before start task, change stack pointer to PSP.
__attribute__((naked)) void change_sp_to_psp(void)
{
	__asm__("PUSH {LR}");
	__asm__("BL get_current_stack");
	__asm__("POP {LR}");

	__asm__("MSR PSP, R0");
	__asm__("MRS R0, CONTROL");
	__asm__("ORR R0, R0, 0x2");
	__asm__("MSR CONTROL, R0");

	__asm__("BX LR");
}

void init_task_stack(struct task_struct * task)
{
	int i;

	// full descending stack. initialize full deschending stack.
	for (i=0; i<DUMMY_STACK_FRAME_SIZE/sizeof(int); i++) {
		if (i==0) {
			*(--task->stack) = 0x1000000; // XPSR T bit is set to high.
		} else if (i==1) {
			*(--task->stack) = (uint32_t)((void *)task->handler + 1); // default PC initialize. first function
		} else if (i==2) {
			*(--task->stack) = 0xFFFFFFFD; // default LR initialize. return to thread mode using PSP.
		} else
			*(--task->stack) = 0x0; // otherwise, intialize with zero.
	}
}

int main(void)
{
	uint32_t *pSHCSR;
	int i;

	pSHCSR = (uint32_t *)SCB_SHCSR_BASE;
	// *pSHCSR |= (1<<18)|(1<<17)|(1<<16); // enable Usage fault, Bus fault, Mem fault.
	*pSHCSR |= (1<<17)|(1<<16); // enable Usage fault, Bus fault, Mem fault.

	init_scheduler_stack(SCHED_STACK_START);

	for (i=0; i<MAX_TASK; i++) {
		init_task_stack(&task_info[i]);
	}

	led_init_all();

	change_sp_to_psp();

	// from now, below code is running as task1 context.
	init_systick_timer( TICK_HZ );

	task1_handler();

    /* Loop forever */
	for(;;);
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t * pSYST_CSR_BASE;
	uint32_t * pSYST_RVR_BASE;

	pSYST_CSR_BASE = (uint32_t *)SYST_CSR_BASE;
	*pSYST_CSR_BASE |= (1<<2)|(1<<1); // enable clock source to processor clock, and exception.

	pSYST_RVR_BASE = (uint32_t *)SYST_RVR_BASE;
	*pSYST_RVR_BASE = (SYSTICK_HZ / tick_hz) - 1;

	*pSYST_CSR_BASE |= (1<<0); // enable systick timer.

}

__attribute__((naked)) void PendSV_Handler(void)
{
	__asm__("PUSH {LR}");
	// 1. save current task context.
	__asm__("MRS R0, PSP");
	__asm__("STMDB R0!, {R4, R5, R6, R7, R8, R9, R10, R11}");
	__asm__("BL pendsv_update_stack_pointer");

	// 2. restore next task context.
	__asm__("BL pendsv_next_task_stack_pointer");
	__asm__("LDMIA R0!, {R4, R5, R6, R7, R8, R9, R10, R11}");
	__asm__("MSR PSP, R0");

	__asm__("POP {LR}");
	__asm__("BX LR");
}

void SysTick_Handler(void)
{
	uint32_t * pICSR = (uint32_t *)SCB_ICSR_BASE;

	cur_task = &task_info[task_count];
	next_task = systick_get_next_task();

	if (cur_task != next_task) {
		// call enable pend SV handler.
		*pICSR |= (0x1<<28); // set pend SV exception pending.
	}

	// save exception return LR magic number.
	// __asm__("BL update_global_counter");
	// __asm__("BL update_running_task");

	// 2. restore next task context.
	// __asm__("BL update_task_count");

	// __asm__("PUSH {R0-R3,R12,LR}");
	// printf("systick handler");
	// __asm__("POP {R0-R3,R12,LR}");
}

void task1_handler(void)
{
	while(1) {
		//printf("%s\n", __func__);
		led_on(LED_GREEN);
		task_delay(1000,0);
		led_off(LED_GREEN);
		task_delay(1000,0);
	}
}

void task2_handler(void)
{
	while(1) {
		//printf("%s\n", __func__);
		led_on(LED_ORANGE);
		task_delay(1000, 1);
		led_off(LED_ORANGE);
		task_delay(1000, 1);
	}
}

void task3_handler(void)
{
	while(1) {
		//printf("%s\n", __func__);
		led_on(LED_RED);
		task_delay(100, 2);
		led_off(LED_RED);
		task_delay(100, 2);
	}
}

void task4_handler(void)
{
	while(1) {
		//printf("%s\n", __func__);
		led_on(LED_BLUE);
		task_delay(500, 3);
		led_off(LED_BLUE);
		task_delay(500, 3);
	}
}

void idle_handler(void)
{
	// idle handler.
	while(1) {
	}
}

__attribute__((naked)) void MemManage_Handler(void)
{
	__asm__("MRS R0, MSP");
	__asm__("PUSH {R4,R5,R6,R7,R8,R9,R10,R11,LR}");
	__asm__("BL __MemManage_Handler");
	__asm__("POP {R4,R5,R6,R7,R8,R9,R10,R11,LR}");
	__asm__("BX LR");
}

void __MemManage_Handler(uint32_t *msp_value)
{
	uint32_t * pMSP = (uint32_t *)msp_value;

	// print stack frame of previous context.
	printf("pMSP: %p\n", pMSP);
	printf("R0: %08x\n", pMSP[0]);
	printf("R1: %08x\n", pMSP[1]);
	printf("R2: %08x\n", pMSP[2]);
	printf("R3: %08x\n", pMSP[3]);
	printf("R12: %08x\n", pMSP[4]);
	printf("LR: %08x\n", pMSP[5]);
	printf("PC: %08x\n", pMSP[6]);
	printf("XPSR: %08x\n", pMSP[7]);

	uint32_t * pMMSR = (uint32_t *)SCB_MMSR_BASE;
	uint32_t * pMMAR = (uint32_t *)SCB_MMAR_BASE;

	uint32_t data = *pMMSR;
	uint32_t addr = *pMMAR;

	printf("MemManage fault status: %08x\n", data);
	printf("MemManage address: %08x\n", addr);

	printf("MemManage fault\n");
}
void BusFault_Handler(void)
{
	printf("Bus fault");
	while(1);
}

__attribute__((naked)) void UsageFault_Handler(void)
{
	__asm__("MRS R0, MSP");
	__asm__("B __UsageFault_Handler");
}

void __UsageFault_Handler(uint32_t *msp_value)
{
	uint32_t * pMSP = (uint32_t *)msp_value;


	// print stack frame of previous context.
	printf("pMSP: %p\n", pMSP);
	printf("R0: %08x\n", pMSP[0]);
	printf("R1: %08x\n", pMSP[1]);
	printf("R2: %08x\n", pMSP[2]);
	printf("R3: %08x\n", pMSP[3]);
	printf("R12: %08x\n", pMSP[4]);
	printf("LR: %08x\n", pMSP[5]);
	printf("PC: %08x\n", pMSP[6]);
	printf("XPSR: %08x\n", pMSP[7]);

	uint32_t * pUFSR = (uint32_t *)SCB_UFSR_BASE;
	uint32_t data = *pUFSR;
	printf("Usage fault status: %08x\n", data);
	printf("usage fault\n");
	while(1);
}


void HardFault_Handler(void)
{
	printf("Hard fault");
	while(1);
}


