/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);


#define TASK_STACK_SIZE	(1024U)
#define SCHED_STACK_SIZE	(1024U)

#define SRAM_BASE	(0x20000000U)
#define SRAM_SIZE	(128U * 1024U)
#define SRAM_END	(SRAM_BASE + SRAM_SIZE)

// normal memory map is defined with base and size.
// but stack memory is full descending.
// lets try with original concept, base and size.

// but look below,, it is confusing.
// #define T1_STACK_SIZE	TASK_STACK_SIZE
// #define T1_STACK_BASE	((SRAM_BASE + SRAM_SIZE) - T1_STACK_SIZE)

// below syntax looks much nicer.
#define T1_STACK_START	(SRAM_END)
#define T1_STACK_SIZE	(TASK_STACK_SIZE)
#define T1_STACK_END	(T1_STACK_START - T1_STACK_SIZE)

#define T2_STACK_START	(T1_STACK_END)
#define T2_STACK_SIZE	(TASK_STACK_SIZE)
#define T2_STACK_END	(T2_STACK_START - T2_STACK_SIZE)

#define T3_STACK_START	(T2_STACK_END)
#define T3_STACK_SIZE	(TASK_STACK_SIZE)
#define T3_STACK_END	(T3_STACK_START - T3_STACK_SIZE)

#define T4_STACK_START	(T3_STACK_END)
#define T4_STACK_SIZE	(TASK_STACK_SIZE)
#define T4_STACK_END	(T4_STACK_START - T4_STACK_SIZE)

#define SCHED_STACK_START	(T4_STACK_END)
#define SCHED_STACK_END	(SCHED_STACK_START - SCHED_STACK_SIZE)

#define MAX_TASK	4

// systick timer
#define SYSTICK_HZ	(16000000)
#define TICK_HZ	(1U) // 1KHZ
#define SYST_CSR_BASE	(0xE000E010)
#define SYST_RVR_BASE	(0xE000E014)


#define SCB_SHCSR_BASE	(0xE000ED24)

#define SCB_UFSR_BASE	(0xE000ED2A)
#define SCB_MMSR_BASE	(0xE000ED28)
#define SCB_MMAR_BASE	(0xE000ED34)
#define SCB_CCR_BASE	(0xE000ED14)

uint32_t * task_stack[MAX_TASK];

int task_count = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void init_systick_timer(uint32_t tick_hz);
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

__attribute__((naked)) void init_scheduler_stack(uint32_t stack_start)
{
	__asm__("MSR MSP, R0");
	__asm__("BX LR");
}

uint32_t * get_current_stack(void)
{
	return task_stack[task_count];
}

// before start task, change stack pointer to PSP.
__attribute__((naked)) void change_sp_to_psp(void)
{
	__asm__("PUSH {LR}");
	__asm__("BL get_current_stack");
	__asm__("POP {LR}");

	__asm__("MSR PSP, R0");
	__asm__("MRS R0, CONTROL");
	__asm__("ORR R0, R0, 0x2");
	__asm__("MSR CONTROL, R0");

	__asm__("BX LR");
}

void init_task_stack(uint32_t **pstack, uint32_t stack_start, uint32_t init_stack_size, void *task_addr)
{
	int i;
	uint32_t * stack_pointer;

	*pstack = (uint32_t *)(stack_start - init_stack_size); // stack pointer is updated to end of stack.

	stack_pointer = *pstack;

	printf("stack pointer: %p\n", stack_pointer);

	// clear all stack contents.
	for(i=0; i<init_stack_size/sizeof(int); i++) {
		stack_pointer[i] = 0;
	}

	stack_pointer[15] = 0x1000000; // XPSR T bit is set to high.
	stack_pointer[14] = (uint32_t)((void *)task_addr + 0x1); // set LSB one.
	stack_pointer[13] = 0xFFFFFFFD; // return to thread mode with PSP.

}

int main(void)
{
	uint32_t *pSHCSR;

	pSHCSR = (uint32_t *)SCB_SHCSR_BASE;
	// *pSHCSR |= (1<<18)|(1<<17)|(1<<16); // enable Usage fault, Bus fault, Mem fault.
	*pSHCSR |= (1<<17)|(1<<16); // enable Usage fault, Bus fault, Mem fault.

	init_scheduler_stack(SCHED_STACK_START);

	init_task_stack(&task_stack[0], T1_STACK_START, 16 * sizeof(int), task1_handler);
	init_task_stack(&task_stack[1], T2_STACK_START, 16 * sizeof(int), task2_handler);
	init_task_stack(&task_stack[2], T3_STACK_START, 16 * sizeof(int), task3_handler);
	init_task_stack(&task_stack[3], T4_STACK_START, 16 * sizeof(int), task4_handler);

	change_sp_to_psp();

	// from now, below code is running as task1 context.
	init_systick_timer( TICK_HZ );

    /* Loop forever */
	for(;;);
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t * pSYST_CSR_BASE;
	uint32_t * pSYST_RVR_BASE;

	pSYST_CSR_BASE = (uint32_t *)SYST_CSR_BASE;
	*pSYST_CSR_BASE |= (1<<2)|(1<<1); // enable clock source to processor clock, and exception.

	pSYST_RVR_BASE = (uint32_t *)SYST_RVR_BASE;
	*pSYST_RVR_BASE = (SYSTICK_HZ / tick_hz) - 1;

	*pSYST_CSR_BASE |= (1<<0); // enable systick timer.

}



void SysTick_Handler(void)
{

	int i;
	// 1. save current task context.
	__asm__("MRS R0, PSP");
	__asm__("STMDB R0!, {R4, R5, R6, R7, R8, R9, R10, R11}");

	// update stack for current task.
	__asm__("MOV %0, R0":"=r"((uint32_t)task_stack[task_count]));

	// decide next task to run
	task_count += 1;
	task_count = task_count % MAX_TASK;

	// 2. restore next task context.
	__asm__("LDMIA %0!, {R4, R5, R6, R7, R8, R9, R10, R11}\n"
			"MSR PSP, %0\n"
			::"r"((uint32_t)task_stack[task_count]));


	i = 5;
}

void task1_handler(void)
{
	int i;
	while(1) {
		if ((i % 100) == 0) {
			printf("task1\n");
			i = 0;
		}

		i++;
	}
}

void task2_handler(void)
{
	int i;
	while(1) {
		if ((i % 100) == 0) {
			printf("task2\n");
			i = 0;
		}
		i++;
	}
}

void task3_handler(void)
{
	int i;
	while(1) {
		if ((i % 100) == 0) {
			printf("task3\n");
			i = 0;
		}
		i++;
	}
}

void task4_handler(void)
{
	int i;
	while(1) {
		if ((i % 100) == 0) {
			printf("task4\n");
			i = 0;
		}
		i++;
	}
}

__attribute__((naked)) void MemManage_Handler(void)
{
	__asm__("MRS R0, MSP");
	__asm__("PUSH {R4,R5,R6,R7,R8,R9,R10,R11,LR}");
	__asm__("BL __MemManage_Handler");
	__asm__("POP {R4,R5,R6,R7,R8,R9,R10,R11,LR}");
	__asm__("BX LR");
}

void __MemManage_Handler(uint32_t *msp_value)
{
	uint32_t * pMSP = (uint32_t *)msp_value;

	// print stack frame of previous context.
	printf("pMSP: %p\n", pMSP);
	printf("R0: %08x\n", pMSP[0]);
	printf("R1: %08x\n", pMSP[1]);
	printf("R2: %08x\n", pMSP[2]);
	printf("R3: %08x\n", pMSP[3]);
	printf("R12: %08x\n", pMSP[4]);
	printf("LR: %08x\n", pMSP[5]);
	printf("PC: %08x\n", pMSP[6]);
	printf("XPSR: %08x\n", pMSP[7]);

	uint32_t * pMMSR = (uint32_t *)SCB_MMSR_BASE;
	uint32_t * pMMAR = (uint32_t *)SCB_MMAR_BASE;

	uint32_t data = *pMMSR;
	uint32_t addr = *pMMAR;

	printf("MemManage fault status: %08x\n", data);
	printf("MemManage address: %08x\n", addr);

	printf("MemManage fault\n");
}
void BusFault_Handler(void)
{
	printf("Bus fault");
	while(1);
}

__attribute__((naked)) void UsageFault_Handler(void)
{
	__asm__("MRS R0, MSP");
	__asm__("B __UsageFault_Handler");
}

void __UsageFault_Handler(uint32_t *msp_value)
{
	uint32_t * pMSP = (uint32_t *)msp_value;


	// print stack frame of previous context.
	printf("pMSP: %p\n", pMSP);
	printf("R0: %08x\n", pMSP[0]);
	printf("R1: %08x\n", pMSP[1]);
	printf("R2: %08x\n", pMSP[2]);
	printf("R3: %08x\n", pMSP[3]);
	printf("R12: %08x\n", pMSP[4]);
	printf("LR: %08x\n", pMSP[5]);
	printf("PC: %08x\n", pMSP[6]);
	printf("XPSR: %08x\n", pMSP[7]);

	uint32_t * pUFSR = (uint32_t *)SCB_UFSR_BASE;
	uint32_t data = *pUFSR;
	printf("Usage fault status: %08x\n", data);
	printf("usage fault\n");
	while(1);
}


void HardFault_Handler(void)
{
	printf("Hard fault");
	while(1);
}


